---
layout: post
title: Redis源码走马观花（8）RDB 与 AOF
date: 2019-12-24
categories: Redis
tags:  数据库 C语言
cover: /assets/img/foods/huafu.jpeg
---

# 引言

RDB 和 AOF 是 Redis 提供的两种数据持久化方式，其中 RDB 存了数据库的完整快照，比较损耗性能，而 AOF 只是把会产生副作用的命令一条条记下来，相对轻量快速，为了降低丢数据的风险，一般会打开 AOF，为了避免 AOF 文件过大，Redis 也会时不时地对其进行整理。

# RDB

## 手动触发：BGSAVE

我们可以使用命令 `SAVE` 或者 `BGSAVE` 来强制触发数据库重写 RDB 文件，`SAVE`使用数据库的主进程来重写 RDB，会导致数据库无法处理更多的命令，所以我们一般使用 `BGSAVE` 创建一个子进程来重写，[rdb.c:1083](https://github.com/DQinYuan/redis-3.0-annotated/blob/unstable/src/rdb.c#L1083)：

```java
    // fork() 开始前的时间，记录 fork() 返回耗时用
    start = ustime();

    if ((childpid = fork()) == 0) {
        //...
        // 在子进程中重写 rdb
        retval = rdbSave(filename);
    }
```

## 走马观花 RDB 文件格式

继续阅读上面代码中的 `rdbSave` 函数，它会先创建一个叫做 `temp-xx.rdb` 的临时文件（其中 `xx` 是指子进程的进程 id），先把数据写到这个文件中，然后再把它重命名为用户指定的 rdb 文件,[rdb.c:938](https://github.com/DQinYuan/redis-3.0-annotated/blob/unstable/src/rdb.c#L938)：

```java
    // 创建临时文件
    snprintf(tmpfile,256,"temp-%d.rdb", (int) getpid());
    fp = fopen(tmpfile,"w");
```

之后 Redis 首先写入自己的 magic number,其实就是 "REDIS" + 版本号，对于 Redis 3.0 来说，就是 "REDIS6",[rdb.c:954](https://github.com/DQinYuan/redis-3.0-annotated/blob/unstable/src/rdb.c#L954)：

```java
    // 写入 RDB 版本号 REDIS0006
    snprintf(magic,sizeof(magic),"REDIS%04d",REDIS_RDB_VERSION);
    if (rdbWriteRaw(&rdb,magic,9) == -1) goto werr;
```

之后遍历所有数据库，遍历所有键值对写入后，写入 `EOF` 和校验和：

```c
    // 遍历所有数据库
    for (j = 0; j < server.dbnum; j++) {
        //...
    }
    if (rdbSaveType(&rdb,REDIS_RDB_OPCODE_EOF) == -1) goto werr;
    cksum = rdb.cksum;
    rioWrite(&rdb,&cksum,8);
```

到此我们就知道一个 RDB 文件大概的样子了：

![rdb文件结构](/assets/img/redis-read/rdb-struct.png)

下面再粗略看看 databases 部分的结构。在 databases 部分，每一个数据的第一个字节标识自己的类型，可以是 `OPCODE` 或者具体的数据类型（比如 `REDIS_RDB_TYPE_LIST_ZIPLIST`，杂揉了数据结构和其底层的具体编码）[rdb.h:97](https://github.com/DQinYuan/redis-3.0-annotated/blob/unstable/src/rdb.h#L97)：

```java
#define REDIS_RDB_TYPE_STRING 0
#define REDIS_RDB_TYPE_LIST   1
#define REDIS_RDB_TYPE_SET    2
#define REDIS_RDB_TYPE_ZSET   3
#define REDIS_RDB_TYPE_HASH   4
//...

//...
#define REDIS_RDB_OPCODE_SELECTDB   254
#define REDIS_RDB_OPCODE_EOF        255
```

databases 部分的开头就是一个 `REDIS_RDB_OPCODE_SELECTDB`,后面紧跟着数据库的编号（RDB 对于数字的存储做了专门的优化，后面再聊）。然后就是所有的键值对，每个键值对的存储格式大概是（如图）：过期时间（如果有设置的话，没有设置就省略这一部分）+ 类型(就是上面给出的这些宏，占一个字节) + 值。其中值会根据不同的类型，采用不同的编码，因为这里只是走马观花，就不细看每种类型值的编码了，如果想要了解的话，可以很容易在代码中找到相关部分并阅读。

![read中单个 kv 存储](/assets/img/redis-read/kvpair.png)

## RDB 中对数字存储的优化




## 数据库自动触发

如果我们不手动触发，数据库会在什么时机重写呢？

在本系列的[第三篇文章（网络层实现）](http://dqyuan.top/2019/11/07/redis-read-3.html)中我们提到，在 Redis 网络层中唯一的定时时间就是 `serverCron`，它默认每隔100ms执行一次， 在 `serverCron`会进行是否需要重写 RDB 文件的判定

